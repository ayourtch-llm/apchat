use crate::agents::agent::{Agent, Task, TaskType, TaskPriority, AgentResult, ExecutionContext};
use crate::agents::agent_factory::AgentFactory;
use crate::agents::agent_config::AgentConfig;
use anyhow::Result;
use std::collections::{HashMap, VecDeque};
use std::sync::Arc;
use tokio::sync::RwLock;
use colored::Colorize;

/// Planning Coordinator - manages task decomposition and agent dispatch
pub struct PlanningCoordinator {
    agent_factory: Arc<AgentFactory>,
    agent_configs: HashMap<String, AgentConfig>,
    task_queue: Arc<RwLock<VecDeque<Task>>>,
    active_agents: Arc<RwLock<HashMap<String, AgentHandle>>>,
    conversation_state: Arc<RwLock<Vec<crate::agents::agent::ChatMessage>>>,
}

#[derive(Debug, Clone)]
struct AgentHandle {
    name: String,
    task_id: String,
    start_time: std::time::Instant,
}

impl PlanningCoordinator {
    pub fn new(agent_factory: Arc<AgentFactory>) -> Self {
        Self {
            agent_factory,
            agent_configs: HashMap::new(),
            task_queue: Arc::new(RwLock::new(VecDeque::new())),
            active_agents: Arc::new(RwLock::new(HashMap::new())),
            conversation_state: Arc::new(RwLock::new(Vec::new())),
        }
    }

    /// Load agent configurations from directory
    pub async fn load_agent_configs(&mut self, config_dir: &std::path::Path) -> Result<()> {
        let mut entries = tokio::fs::read_dir(config_dir).await?;

        while let Some(entry) = entries.next_entry().await? {
            let path = entry.path();
            if path.extension().and_then(|s| s.to_str()) == Some("json") {
                let content = tokio::fs::read_to_string(&path).await?;
                let config: AgentConfig = serde_json::from_str(&content)?;

                // Validate configuration
                config.validate()
                    .map_err(|e| anyhow::anyhow!("Invalid config in {}: {}", path.display(), e))?;

                self.agent_configs.insert(config.name.clone(), config);
                println!("{} Loaded agent configuration: {}", "üìã".blue(), path.display());
            }
        }

        Ok(())
    }

    /// Process a user request and coordinate agent execution
    pub async fn process_user_request(
        &mut self,
        request: &str,
        context: &ExecutionContext,
    ) -> Result<AgentResult> {
        // Enhanced request processing header
        println!("{}", "‚ïê".repeat(100).bright_magenta());
        println!("{}", "üéØ REQUEST PROCESSING INITIATED".bright_magenta().bold());
        println!("{}", "‚ïê".repeat(100).bright_magenta());
        println!("{} {}", "Request:".bright_cyan(), request.white());
        println!();

        let request_start = std::time::Instant::now();

        println!("{}", "üîç Analyzing and decomposing request...".yellow());
        
        // 1. Analyze request and create initial task
        let initial_task = self.analyze_request(request).await?;

        // 2. Decompose task if needed
        let tasks = self.decompose_task(initial_task).await?;
        
        let task_count = tasks.len();
        println!("{}", "‚úÖ Request decomposition complete".green());
        println!("{} {}", "üìä Total tasks identified:".bright_blue(), task_count.to_string().bright_yellow());
        println!();
        
        // Show task overview
        if !tasks.is_empty() {
            println!("{}", "üìã Task Breakdown:".bright_cyan().bold());
            for (i, task) in tasks.iter().enumerate() {
                let priority_icon = match task.priority {
                    crate::agents::agent::TaskPriority::High => "üî¥",
                    crate::agents::agent::TaskPriority::Medium => "üü°",
                    crate::agents::agent::TaskPriority::Low => "üü¢",
                };
                println!("  {} {} {} - {} ({})", 
                    format!("#{}", i + 1).bright_white(),
                    priority_icon,
                    task.description.bright_white(),
                    format!("{:?}", task.task_type).cyan(),
                    format!("{:?}", task.priority).yellow()
                );
            }
            println!();
        }

        // 3. Add tasks to queue
        {
            let mut queue = self.task_queue.write().await;
            for task in tasks {
                queue.push_back(task);
            }
        }

        // 4. Execute all tasks
        let mut results = Vec::new();
        let mut total_execution_time = std::time::Duration::new(0, 0);
        
        while !self.task_queue.read().await.is_empty() {
            let task_start = std::time::Instant::now();
            let result = self.execute_next_task(context).await?;
            let task_duration = task_start.elapsed();
            total_execution_time += task_duration;
            
            results.push(result);

            // Add any new tasks generated by this execution
            if let Some(next_tasks) = results.last().and_then(|r| r.next_tasks.clone()) {
                let mut queue = self.task_queue.write().await;
                for task in next_tasks {
                    queue.push_back(task);
                }
            }
        }
        
        // Enhanced completion summary
        let total_duration = request_start.elapsed();
        
        println!("{}", "‚ïê".repeat(100).bright_green());
        println!("{}", "üéâ REQUEST PROCESSING COMPLETE".bright_green().bold());
        println!("{}", "‚ïê".repeat(100).bright_green());
        println!("{} {}", "üìä Total tasks executed:".bright_blue(), results.len().to_string().bright_yellow());
        println!("{} {}", "‚è±Ô∏è  Total execution time:".bright_blue(), format!("{:?}", total_duration).bright_white());
        println!("{} {:.1}s", "‚ö° Average time per task:".bright_blue(), total_duration.as_secs_f64() / results.len().max(1) as f64);

        // 5. Synthesize final response
        self.synthesize_response(results).await
    }

    /// Analyze user request and create initial task
    async fn analyze_request(&self, request: &str) -> Result<Task> {
        let task_id = format!("task_{}", chrono::Utc::now().timestamp_nanos_opt().unwrap_or(0));

        // Simple heuristics for task analysis
        let (task_type, priority) = if request.contains(" and ") || request.contains(" then ") || request.contains(" after ") {
            (TaskType::Complex, TaskPriority::High)
        } else if request.len() > 200 {
            (TaskType::Complex, TaskPriority::Medium)
        } else {
            (TaskType::Simple, TaskPriority::Medium)
        };

        Ok(Task {
            id: task_id,
            description: request.to_string(),
            task_type,
            priority,
            metadata: HashMap::new(),
        })
    }

    /// Decompose complex tasks into subtasks
    async fn decompose_task(&self, task: Task) -> Result<Vec<Task>> {
        match task.task_type {
            TaskType::Simple => Ok(vec![task]),
            TaskType::Complex => self.decompose_complex_task(task).await,
            TaskType::Parallel(subtasks) => Ok(subtasks),
            TaskType::Sequential(subtasks) => Ok(subtasks),
        }
    }

    /// Decompose a complex task into simpler subtasks
    async fn decompose_complex_task(&self, task: Task) -> Result<Vec<Task>> {
        let description = task.description.to_lowercase();
        let mut subtasks = Vec::new();

        // Common patterns for task decomposition
        if description.contains("read") && description.contains("write") {
            // Separate read and write operations
            subtasks.push(Task {
                id: format!("{}_read", task.id),
                description: "Read the relevant files".to_string(),
                task_type: TaskType::Simple,
                priority: TaskPriority::High,
                metadata: HashMap::new(),
            });

            subtasks.push(Task {
                id: format!("{}_write", task.id),
                description: "Write the updated content".to_string(),
                task_type: TaskType::Simple,
                priority: TaskPriority::High,
                metadata: HashMap::new(),
            });
        } else if description.contains("search") && description.contains("modify") {
            // Search then modify pattern
            subtasks.push(Task {
                id: format!("{}_search", task.id),
                description: "Search for the relevant code/files".to_string(),
                task_type: TaskType::Simple,
                priority: TaskPriority::High,
                metadata: HashMap::new(),
            });

            subtasks.push(Task {
                id: format!("{}_modify", task.id),
                description: "Modify the found code/files".to_string(),
                task_type: TaskType::Simple,
                priority: TaskPriority::High,
                metadata: HashMap::new(),
            });
        } else {
            // Default: keep as single task but mark for specialized agent
            subtasks.push(task);
        }

        Ok(subtasks)
    }

    /// Execute the next task in the queue
    async fn execute_next_task(&self, context: &ExecutionContext) -> Result<AgentResult> {
        let task = {
            let mut queue = self.task_queue.write().await;
            queue.pop_front()
                .ok_or_else(|| anyhow::anyhow!("No tasks in queue"))?
        };

        println!("{} Executing task: {}", "‚ö°".cyan(), task.description);

        let start_time = std::time::Instant::now();

        // Find suitable agent for this task
        let agent = self.find_suitable_agent(&task).await?;

        // Create execution context for this specific task
        let task_context = ExecutionContext {
            workspace_dir: context.workspace_dir.clone(),
            session_id: context.session_id.clone(),
            tool_registry: Arc::clone(&context.tool_registry),
            llm_client: Arc::clone(&context.llm_client),
            conversation_history: context.conversation_history.clone(),
        };

        // Execute task with progress tracking
        println!("{}", "üîÑ Executing with agent...".yellow());
        let result = agent.execute(task.clone(), &task_context).await;
        
        let execution_time = start_time.elapsed();
        
        match &result {
            Ok(agent_result) => {
                match agent_result {
                    AgentResult::Success { output, .. } => {
                        println!("{}", "‚úÖ TASK COMPLETED SUCCESSFULLY".green().bold());
                        println!("{}", format!("‚è±Ô∏è  Execution time: {:?}", execution_time).bright_blue());
                        if !output.is_empty() {
                            println!("{}", "üìÑ Output:".bright_cyan());
                            println!("{}", output);
                        }
                    }
                    AgentResult::Error { error, .. } => {
                        println!("{}", "‚ùå TASK FAILED".red().bold());
                        println!("{}", format!("‚è±Ô∏è  Execution time: {:?}", execution_time).bright_blue());
                        println!("{}", format!("üí• Error: {}", error).red());
                    }
                    AgentResult::Retry { reason, .. } => {
                        println!("{}", "üîÑ TASK NEEDS RETRY".yellow().bold());
                        println!("{}", format!("‚è±Ô∏è  Execution time: {:?}", execution_time).bright_blue());
                        println!("{} {}", "üìù Reason:".yellow(), reason.yellow());
                    }
                }
            }
            Err(error) => {
                println!("{}", "‚ùå TASK EXECUTION ERROR".red().bold());
                println!("{}", format!("üí• Error: {}", error).red());
            }
        }

        // Update conversation history
        {
            let mut history = self.conversation_state.write().await;
            history.push(crate::agents::agent::ChatMessage {
                role: "assistant".to_string(),
                content: format!("Agent '{}' completed task: {}", agent.name(), task.description),
                tool_calls: None,
            });
        }

        println!("{} Task completed by: {}", "‚úÖ".green(), agent.name());

        Ok(result)
    }

    /// Find the best agent for a given task
    async fn find_suitable_agent(&self, task: &Task) -> Result<Arc<dyn Agent>> {
        // Enhanced agent selection display
        println!("{}", "üîç Agent Selection Analysis".bright_blue().bold());
        println!("{} {}", "Task:".bright_cyan(), task.description.white());
        println!("{} {:?}", "Required capabilities:".bright_cyan(), task.required_capabilities);
        
        let mut candidates = Vec::new();
        
        // Collect all candidate agents
        for (agent_name, config) in &self.agent_configs {
            let agent = self.agent_factory.create_agent(config)?;

            if agent.can_handle(task) {
                let capabilities = agent.get_capabilities();
                let matching_caps: Vec<String> = capabilities
                    .iter()
                    .filter(|cap| task.required_capabilities.contains(&cap.name))
                    .map(|cap| cap.name.clone())
                    .collect();
                
                candidates.push((agent_name.clone(), agent, matching_caps.len()));
            }
        }
        
        // Show all candidate agents
        if !candidates.is_empty() {
            println!("{}", "Available agents:".bright_cyan());
            for (i, (agent_name, _, matches)) in candidates.iter().enumerate() {
                let status = if i == 0 { "‚úì SELECTED" } else { "‚óã Available" };
                println!("  {} {} - {} matching capabilities", 
                    status.green(),
                    agent_name.bright_white(),
                    matches.to_string().bright_green()
                );
            }
            println!();
            
            // Select the first candidate (best match)
            let (agent_name, agent, _) = candidates.into_iter().next().unwrap();
            println!("{}", format!("üéØ Selected agent '{}'", agent_name).cyan().bold());
            return Ok(Arc::from(agent));
        }

        // Fallback to a general-purpose agent
        if let Some(config) = self.agent_configs.values().next() {
            let agent = self.agent_factory.create_agent(config)?;
            println!("{} Using fallback agent for task", "üîÑ".yellow());
            return Ok(Arc::from(agent));
        }

        Err(anyhow::anyhow!("No suitable agent found for task"))
    }

    /// Synthesize final response from multiple agent results
    async fn synthesize_response(&self, results: Vec<AgentResult>) -> Result<AgentResult> {
        if results.is_empty() {
            return Ok(AgentResult::error(
                "No tasks were executed".to_string(),
                "synthesis".to_string(),
                "coordinator".to_string(),
            ));
        }

        if results.len() == 1 {
            return Ok(results.into_iter().next().unwrap());
        }

        // Combine multiple results
        let mut combined_content = String::new();
        let mut all_success = true;
        let mut total_time = 0u64;

        for result in &results {
            if !result.success {
                all_success = false;
            }
            total_time += result.execution_time;

            combined_content.push_str(&format!(
                "### Result from {}\n\n{}\n\n",
                result.agent_name,
                result.content
            ));
        }

        let final_result = AgentResult {
            success: all_success,
            content: combined_content.trim().to_string(),
            task_id: "synthesis".to_string(),
            agent_name: "coordinator".to_string(),
            execution_time: total_time,
            metadata: HashMap::new(),
            next_tasks: None,
        };

        println!("{} Synthesized response from {} agents", "üé®".blue(), results.len());

        Ok(final_result)
    }

    /// Get current task queue status
    pub async fn get_queue_status(&self) -> (usize, usize) {
        let queue_size = self.task_queue.read().await.len();
        let active_agents = self.active_agents.read().await.len();
        (queue_size, active_agents)
    }
}